// ============================================
// PROBLEM INFO
// ============================================
//
// 백준 p2108 [통계학]
//
// 수를 처리하는 것은 통계학에서 상당히 중요한 일이다.
// 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다.
// 단, N은 홀수라고 가정하자.
//
// 산술평균 : N개의 수들의 합을 N으로 나눈 값
// 중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값
// 최빈값 : N개의 수들 중 가장 많이 나타나는 값
// 범위 : N개의 수들 중 최댓값과 최솟값의 차이
// N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.
//
// [입력]
// 첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다.
// 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다.
// 입력되는 정수의 절댓값은 4,000을 넘지 않는다.
//
// [출력]
// 첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.
// 둘째 줄에는 중앙값을 출력한다.
// 셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.
// 넷째 줄에는 범위를 출력한다.
//
// https://www.acmicpc.net/problem/2108
//
// ============================================
// IMPORT LIBRARY, HEADERS
// ============================================
#include <iostream>
#include <vector>
#include <string>
#include <numeric>
#include <map>
#include <cmath>
using namespace std;
// ============================================
// FUNC
// ============================================
// 커스텀 정렬 함수
bool cmp(pair<int, int> &p1, pair<int, int> &p2)
{
	// 출현 빈도 같은 경우, 수의 크기(first) 오름차순 정렬
	if (p1.second == p2.second)
	{
		return p1.first < p2.first;
	}
	// 출현 빈도(second) 내림차순 정렬
	return p1.second > p2.second;
}

int get_mode(vector<int> &v)
{
	map<int, int> m;
	for (int n : v)
	{
		// map에 n이 없는 경우 0으로 초기화
		if (m.find(n) == m.end())
		{
			m[n] = 0;
		}
		// n을 발견할 때마다 1씩 count 증가
		m[n]++;
	}

	// 원하는 대로 정렬하기 위해 map을 vector로 변환
	// map은 KEY, VALUE 가지므로
	// vector로 만들면 pair<KEY, VALUE>의 형태가 됨
	vector<pair<int, int>> mv(m.begin(), m.end());
	sort(mv.begin(), mv.end(), cmp);

	// 출현 빈도가 같은 값이 존재하는 경우,
	// 2번째로 작은 값(index 1에 위치) return
	if (mv[0].second == mv[1].second)
	{
		return mv[1].first;
	}
	// 아닌 경우 출현 빈도가 가장 큰 값 return
	return mv[0].first;
}

int main()
{
	// ============================================
	// [FAST INPUT, OUTPUT]
	// 편의를 위해 필요 없는 문제에도 일괄적으로 적용
	// ============================================
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	//
	//
	//
	// ============================================
	// [INPUT]
	// 1 ≤ N ≤ 500,000
	// N은 홀수
	// ============================================
	int N;
	cin >> N;
	//
	//
	//
	// ============================================
	// [VECTOR INPUT]
	// 절댓값 4,000 이하의 N개의 수 입력
	//
	// -> size N인 vector<string> 생성
	// ============================================
	vector<int> V(N);
	for (int i = 0; i < N; i++)
	{
		cin >> V[i];
	}
	//
	//
	//
	// ============================================
	// [MAIN LOGIC1]
	// 산술 평균은 Vector로,
	// 중앙값, 범위는 Sorted Vector로 구할 수 있음
	// ============================================
	//
	// 1. 산술 평균
	int avg = round(accumulate(V.begin(), V.end(), 0) / (double)N);
	//
	//
	//
	// 중앙값, 범위를 구하기 위해서는 오름차순 sort 필요
	sort(V.begin(), V.end());
	//
	//
	//
	// 2. 중앙값
	// N은 항상 홀수라고 하였으므로 N / 2는 항상 배열의 중간 index
	// ex)
	// V = [1,2,3]이면 V / 2 = 1
	// V[1]은 중간 index가 되며, 길이가 얼마가 되던지
	// 홀수인 경우 모두 동일하게 적용됨
	int median = V[V.size() / 2];
	//
	//
	//
	// 3. 범위(편의상 3번째로 구하지만 출력은 4번째)
	// V가 오름차순 정렬된 상태이므로
	// 마지막 index에 위치한 값에서
	// 0번째 index에 위치한 값을 빼면
	// 최댓값 - 최솟값이 됨
	int range = V[V.size() - 1] - V[0];
	//
	//
	//
	// 4. 최빈값(편의상 4번째로 구하지만 출력은 3번째)
	// 최빈값을 구하기 위해서는 모든 수의 출현 빈도를 알아야 함
	// Map을 활용하여 각 수의 누적합(출현 빈도)을 구한 뒤,
	// Vector로 변환하여 누적합이 큰 순으로 정렬하는 방법
	// 위의 `get_mode()` 참조
	// ============================================
	int mode = get_mode(V);
	// ============================================
	//
	//
	//
	// ============================================
	// [PRINT]
	// ============================================
	cout << avg << '\n';
	cout << median << '\n';
	cout << mode << '\n';
	cout << range << '\n';

	return 0;
}
